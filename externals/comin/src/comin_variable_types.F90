!> @file comin_variable_types.F90
!! @brief Data types for variable definition
!
!  @authors 08/2021 :: ICON Community Interface  <comin@icon-model.org>
!
!  SPDX-License-Identifier: BSD-3-Clause
!
!  See LICENSES for license information.
!  Where software is supplied by third parties, it is indicated in the
!  headers of the routines.
!
MODULE comin_variable_types

  USE iso_c_binding,           ONLY: c_int, c_char, c_bool
  USE comin_setup_constants,   ONLY: wp, COMIN_ZAXIS_3D, &
    &                                COMIN_HGRID_UNSTRUCTURED_CELL
  IMPLICIT NONE

  PUBLIC




  ! ------------------------------------
  ! data types for variable definition
  ! ------------------------------------

  !> Variable descriptor.
  !> identifies (uniquely) a variable. Do not confuse with meta-data
  !! @ingroup common
  TYPE :: t_comin_var_descriptor
    CHARACTER(LEN=:), ALLOCATABLE :: name
    ! domain id
    INTEGER                       :: id
  END TYPE t_comin_var_descriptor

  TYPE, BIND(C) :: t_comin_var_descriptor_c
     CHARACTER(KIND=c_char) :: name(32+1)
     ! domain id
     INTEGER(kind=c_int)    :: id
   END TYPE t_comin_var_descriptor_c

  !> Variable meta-data (a subset of ICON's variable meta-data).
  !  Host application (ICON) fills these by "comin_var_list_append" calls.
  !
  TYPE :: t_comin_var_metadata
    !> integer constant, which gives an interpretation of the horizontal
    !> grid location (cell, edge, vertex).
    INTEGER(kind=c_int)  :: hgrid_id = COMIN_HGRID_UNSTRUCTURED_CELL

    !> integer constant, which gives an interpretation of the vertical
    !> axis (2D, atmospheric levels, ...).
    INTEGER(kind=c_int)  :: zaxis_id = COMIN_ZAXIS_3D

    !> LOGICAL flag. TRUE, if this is a restart variable
    LOGICAL(kind=c_bool) :: restart = .FALSE.

    !> LOGICAL flag. TRUE, if this is a tracer variable
    LOGICAL(kind=c_bool) :: tracer = .FALSE.
    !> LOGICAL flag. TRUE if this tracer shall take part in turbulent transport
    LOGICAL(kind=c_bool) :: tracer_turb = .FALSE.
    !> LOGICAL flag. TRUE if this tracer shall take part in convective transport
    LOGICAL(kind=c_bool) :: tracer_conv = .FALSE.
    !> INTEGER, method of horizontal tracer transport
    INTEGER(kind=c_int)  :: tracer_hadv = -1
    !> INTEGER, method of vertical tracer transport
    INTEGER(kind=c_int)  :: tracer_vadv = -1
    !> vertical and horizontal limiters
    INTEGER(kind=c_int)  :: tracer_vlimit = -1
    INTEGER(kind=c_int)  :: tracer_hlimit = -1

    !> cf metadata, from t_cf_var
    CHARACTER(LEN=128, kind=c_char) :: units = ""
    CHARACTER(LEN=128, kind=c_char) :: standard_name = ""
    CHARACTER(LEN=256, kind=c_char) :: long_name     = ""
    CHARACTER(LEN=256, kind=c_char) :: short_name    = ""

  END TYPE t_comin_var_metadata

  !> Variable pointer. Basically this wraps a 5-dimensional REAL(wp)
  !> pointer together with some interpretation of the different array
  !> dimensions.
  !! @ingroup common
  TYPE :: t_comin_var_ptr
     REAL(wp), POINTER :: ptr(:,:,:,:,:) => NULL()

    ! index positions in the 5D array.
    INTEGER :: pos_jc = -1, pos_jk = -1, pos_jb = -1, pos_jn = -1

    !> if (tracer==.TRUE.) and (ncontained > 0), then the variable
    !  pointer refers to an array slice pointer
    !  ptr(:,:,:,:,ncontained)
    INTEGER :: ncontained = 0
    !> LOGICAL flag. TRUE, if this is a container (contains variables)
    LOGICAL(kind=c_bool) :: lcontainer = .FALSE.
  END TYPE t_comin_var_ptr

  !> Variable item
  TYPE :: t_comin_var_item
    TYPE(t_comin_var_descriptor),POINTER :: descriptor
    TYPE(t_comin_var_metadata)           :: metadata
    TYPE(t_comin_var_ptr),   POINTER     :: p => NULL()
  END TYPE t_comin_var_item

  !> Variable list for context access
  TYPE, EXTENDS(t_comin_var_item) :: t_comin_var_context_item
    INTEGER :: access_flag
  END TYPE t_comin_var_context_item

  !> Information on requested variables
  TYPE :: t_comin_request_item
    TYPE(t_comin_var_descriptor)    :: descriptor
    TYPE(t_comin_var_metadata)      :: metadata
    INTEGER, ALLOCATABLE            :: moduleID(:)

    !> LOGICAL flag. TRUE, if this variable is intended to be used
    !> exclusively by a particular 3rd party plugin:
    LOGICAL(kind=c_bool) :: lmodexclusive = .FALSE.
  END TYPE t_comin_request_item

  ! ------------------------------------
  ! lists of exposed variables
  ! ------------------------------------

  ! *** DO NOT EDIT MANUALLY! ***
  !     Generated by fypp script in utils/.
  ! *** DO NOT EDIT MANUALLY! ***

  ! linked list for variable descriptors
  !
  TYPE :: t_var_descr_list
    TYPE(t_comin_var_descr_list_item), POINTER :: firstptr => NULL()
  CONTAINS
    PROCEDURE :: append      => var_descr_list_append
    PROCEDURE :: delete_list => var_descr_list_delete_list
    PROCEDURE :: first       => var_descr_list_first
  END TYPE t_var_descr_list

  ! type(t_comin_var_descr_list_item) is the list item type.
  ! These are allocated by newitem.
  !
  TYPE :: t_comin_var_descr_list_item
    TYPE(t_comin_var_descriptor), ALLOCATABLE :: item_value
    TYPE(t_comin_var_descr_list_item), POINTER :: nextptr => NULL(), prevptr => NULL()
    TYPE(t_var_descr_list), PRIVATE, POINTER :: upptr => NULL()
  CONTAINS
    PROCEDURE :: list   => var_descr_list_item_list
    PROCEDURE :: next   => var_descr_list_item_next
    PROCEDURE :: remove => var_descr_list_item_remove
  END TYPE t_comin_var_descr_list_item

  ! user-defined constructor
  INTERFACE t_comin_var_descr_list_item
    MODULE PROCEDURE var_descr_list_newitem
  END INTERFACE t_comin_var_descr_list_item

  ! linked list for variable descriptors
  !
  TYPE :: t_var_list
    TYPE(t_var_list_item), POINTER :: firstptr => NULL()
  CONTAINS
    PROCEDURE :: append      => var_list_append
    PROCEDURE :: delete_list => var_list_delete_list
    PROCEDURE :: first       => var_list_first
  END TYPE t_var_list

  ! type(t_var_list_item) is the list item type.
  ! These are allocated by newitem.
  !
  TYPE :: t_var_list_item
    TYPE(t_comin_var_item), ALLOCATABLE :: item_value
    TYPE(t_var_list_item), POINTER :: nextptr => NULL(), prevptr => NULL()
    TYPE(t_var_list), PRIVATE, POINTER :: upptr => NULL()
  CONTAINS
    PROCEDURE :: list   => var_list_item_list
    PROCEDURE :: next   => var_list_item_next
    PROCEDURE :: remove => var_list_item_remove
  END TYPE t_var_list_item

  ! user-defined constructor
  INTERFACE t_var_list_item
    MODULE PROCEDURE var_list_newitem
  END INTERFACE t_var_list_item

  ! linked list for variable descriptors
  !
  TYPE :: t_var_context_list
    TYPE(t_var_context_list_item), POINTER :: firstptr => NULL()
  CONTAINS
    PROCEDURE :: append      => var_context_list_append
    PROCEDURE :: delete_list => var_context_list_delete_list
    PROCEDURE :: first       => var_context_list_first
  END TYPE t_var_context_list

  ! type(t_var_context_list_item) is the list item type.
  ! These are allocated by newitem.
  !
  TYPE :: t_var_context_list_item
    TYPE(t_comin_var_context_item), ALLOCATABLE :: item_value
    TYPE(t_var_context_list_item), POINTER :: nextptr => NULL(), prevptr => NULL()
    TYPE(t_var_context_list), PRIVATE, POINTER :: upptr => NULL()
  CONTAINS
    PROCEDURE :: list   => var_context_list_item_list
    PROCEDURE :: next   => var_context_list_item_next
    PROCEDURE :: remove => var_context_list_item_remove
  END TYPE t_var_context_list_item

  ! user-defined constructor
  INTERFACE t_var_context_list_item
    MODULE PROCEDURE var_context_list_newitem
  END INTERFACE t_var_context_list_item

  ! linked list for variable descriptors
  !
  TYPE :: t_var_request_list
    TYPE(t_var_request_list_item), POINTER :: firstptr => NULL()
  CONTAINS
    PROCEDURE :: append      => var_request_list_append
    PROCEDURE :: delete_list => var_request_list_delete_list
    PROCEDURE :: first       => var_request_list_first
  END TYPE t_var_request_list

  ! type(t_var_request_list_item) is the list item type.
  ! These are allocated by newitem.
  !
  TYPE :: t_var_request_list_item
    TYPE(t_comin_request_item), ALLOCATABLE :: item_value
    TYPE(t_var_request_list_item), POINTER :: nextptr => NULL(), prevptr => NULL()
    TYPE(t_var_request_list), PRIVATE, POINTER :: upptr => NULL()
  CONTAINS
    PROCEDURE :: list   => var_request_list_item_list
    PROCEDURE :: next   => var_request_list_item_next
    PROCEDURE :: remove => var_request_list_item_remove
  END TYPE t_var_request_list_item

  ! user-defined constructor
  INTERFACE t_var_request_list_item
    MODULE PROCEDURE var_request_list_newitem
  END INTERFACE t_var_request_list_item


  !> Array of variable lists (array of pointer lists) each entry
  !  stores the lists of variables registered for the context
  !  (dimension of array) points to the first element of the variable
  !  list
  !  - contains TYPE(t_comin_var_item)
  TYPE :: t_comin_var_list_context
    TYPE(t_var_context_list) :: var_list
  END TYPE t_comin_var_list_context

CONTAINS

  ! *** DO NOT EDIT MANUALLY! ***
  !     Generated by fypp script in utils/.
  ! *** DO NOT EDIT MANUALLY! ***

  ! Create a new (orphaned) list item.
  !
  FUNCTION var_descr_list_newitem(something) RESULT(newitem)
    TYPE(t_comin_var_descriptor), INTENT(in) :: something
    TYPE(t_comin_var_descr_list_item), POINTER :: newitem
    ALLOCATE (newitem)
    newitem%item_value = something
    newitem%prevptr => newitem
  END FUNCTION var_descr_list_newitem

  ! Append an item to a list.
  !
  SUBROUTINE var_descr_list_append(list, item)
    CLASS(t_var_descr_list), INTENT(inout), TARGET :: list
    TYPE(t_comin_var_descr_list_item), TARGET            :: item
    TYPE(t_comin_var_descr_list_item), POINTER           :: last
    IF (ASSOCIATED(item%upptr)) CALL item%remove()
    item%upptr => list
    IF (ASSOCIATED(list%firstptr)) THEN
      last => list%firstptr%prevptr
      last%nextptr => item
      item%prevptr => last
      list%firstptr%prevptr => item
    ELSE
      list%firstptr => item
      item%prevptr => item
    END IF
  END SUBROUTINE var_descr_list_append

  ! Delete the contents of a list.
  !
  SUBROUTINE var_descr_list_delete_list(list)
    CLASS(t_var_descr_list), INTENT(inout) :: list
    DO
      IF (.NOT.ASSOCIATED(list%firstptr)) EXIT
      CALL var_descr_list_delete(list%firstptr)
    END DO
  END SUBROUTINE var_descr_list_delete_list

  ! Return the first element of a list.
  !
  FUNCTION var_descr_list_first(list) RESULT(first)
    CLASS(t_var_descr_list), INTENT(in) :: list
    TYPE(t_comin_var_descr_list_item), POINTER :: first
    first => list%firstptr
  END FUNCTION var_descr_list_first

  ! Delete an item: removes it from the list and deallocates it.
  !
  SUBROUTINE var_descr_list_delete(item)
    ! We want to deallocate the dummy argument, so it must be a pointer.
    ! It follows that the procedure cannot be a type-bound procedure.
    TYPE(t_comin_var_descr_list_item), POINTER :: item
    TYPE(t_comin_var_descr_list_item), POINTER :: ptr
    ptr => item
    CALL item%remove()
    DEALLOCATE (ptr)
    NULLIFY(item)
  END SUBROUTINE var_descr_list_delete

  ! Return the list that an item is a member of.  Null if an orphan.
  !
  FUNCTION var_descr_list_item_list(item) RESULT(list)
    CLASS(t_comin_var_descr_list_item), INTENT(in) :: item
    TYPE(t_var_descr_list), POINTER :: list
    list => item%upptr
  END FUNCTION var_descr_list_item_list

  ! Return the next item in the list.
  !
  FUNCTION var_descr_list_item_next(item)  RESULT(next)
    CLASS(t_comin_var_descr_list_item), INTENT(in) :: item
    TYPE(t_comin_var_descr_list_item), POINTER :: next
    next => item%nextptr
  END FUNCTION var_descr_list_item_next

  ! Remove an item from a list (but keep it and its value).
  !
  SUBROUTINE var_descr_list_item_remove(item)
    CLASS(t_comin_var_descr_list_item), INTENT(inout), TARGET :: item
    TYPE(t_var_descr_list), POINTER :: list
    list => item%upptr
    IF (ASSOCIATED(list)) THEN
      IF (ASSOCIATED(item%prevptr, item)) THEN
        ! Single item in list.
        NULLIFY(list%firstptr)
      ELSE IF (.NOT.ASSOCIATED(item%nextptr)) THEN
        ! Last item in list.
        list%firstptr%prevptr => item%prevptr
        NULLIFY(item%prevptr%nextptr)
      ELSE IF (ASSOCIATED(list%firstptr, item)) THEN
        ! First item in list.
        list%firstptr => item%nextptr         ! first = next.
        item%prevptr%prevptr => item%nextptr  ! last%prev = item%next.
        item%nextptr%prevptr => item%prevptr  ! next%prev = last.
      ELSE
        item%prevptr%nextptr => item%nextptr  ! last%next = item%next.
        item%nextptr%prevptr => item%prevptr  ! next%prev = item%last.
      end if
      item%prevptr => item
    END IF
    NULLIFY(item%upptr)
  END SUBROUTINE var_descr_list_item_remove

  ! Create a new (orphaned) list item.
  !
  FUNCTION var_list_newitem(something) RESULT(newitem)
    TYPE(t_comin_var_item), INTENT(in) :: something
    TYPE(t_var_list_item), POINTER :: newitem
    ALLOCATE (newitem)
    newitem%item_value = something
    newitem%prevptr => newitem
  END FUNCTION var_list_newitem

  ! Append an item to a list.
  !
  SUBROUTINE var_list_append(list, item)
    CLASS(t_var_list), INTENT(inout), TARGET :: list
    TYPE(t_var_list_item), TARGET            :: item
    TYPE(t_var_list_item), POINTER           :: last
    IF (ASSOCIATED(item%upptr)) CALL item%remove()
    item%upptr => list
    IF (ASSOCIATED(list%firstptr)) THEN
      last => list%firstptr%prevptr
      last%nextptr => item
      item%prevptr => last
      list%firstptr%prevptr => item
    ELSE
      list%firstptr => item
      item%prevptr => item
    END IF
  END SUBROUTINE var_list_append

  ! Delete the contents of a list.
  !
  SUBROUTINE var_list_delete_list(list)
    CLASS(t_var_list), INTENT(inout) :: list
    DO
      IF (.NOT.ASSOCIATED(list%firstptr)) EXIT
      CALL var_list_delete(list%firstptr)
    END DO
  END SUBROUTINE var_list_delete_list

  ! Return the first element of a list.
  !
  FUNCTION var_list_first(list) RESULT(first)
    CLASS(t_var_list), INTENT(in) :: list
    TYPE(t_var_list_item), POINTER :: first
    first => list%firstptr
  END FUNCTION var_list_first

  ! Delete an item: removes it from the list and deallocates it.
  !
  SUBROUTINE var_list_delete(item)
    ! We want to deallocate the dummy argument, so it must be a pointer.
    ! It follows that the procedure cannot be a type-bound procedure.
    TYPE(t_var_list_item), POINTER :: item
    TYPE(t_var_list_item), POINTER :: ptr
    ptr => item
    CALL item%remove()
    DEALLOCATE (ptr)
    NULLIFY(item)
  END SUBROUTINE var_list_delete

  ! Return the list that an item is a member of.  Null if an orphan.
  !
  FUNCTION var_list_item_list(item) RESULT(list)
    CLASS(t_var_list_item), INTENT(in) :: item
    TYPE(t_var_list), POINTER :: list
    list => item%upptr
  END FUNCTION var_list_item_list

  ! Return the next item in the list.
  !
  FUNCTION var_list_item_next(item)  RESULT(next)
    CLASS(t_var_list_item), INTENT(in) :: item
    TYPE(t_var_list_item), POINTER :: next
    next => item%nextptr
  END FUNCTION var_list_item_next

  ! Remove an item from a list (but keep it and its value).
  !
  SUBROUTINE var_list_item_remove(item)
    CLASS(t_var_list_item), INTENT(inout), TARGET :: item
    TYPE(t_var_list), POINTER :: list
    list => item%upptr
    IF (ASSOCIATED(list)) THEN
      IF (ASSOCIATED(item%prevptr, item)) THEN
        ! Single item in list.
        NULLIFY(list%firstptr)
      ELSE IF (.NOT.ASSOCIATED(item%nextptr)) THEN
        ! Last item in list.
        list%firstptr%prevptr => item%prevptr
        NULLIFY(item%prevptr%nextptr)
      ELSE IF (ASSOCIATED(list%firstptr, item)) THEN
        ! First item in list.
        list%firstptr => item%nextptr         ! first = next.
        item%prevptr%prevptr => item%nextptr  ! last%prev = item%next.
        item%nextptr%prevptr => item%prevptr  ! next%prev = last.
      ELSE
        item%prevptr%nextptr => item%nextptr  ! last%next = item%next.
        item%nextptr%prevptr => item%prevptr  ! next%prev = item%last.
      end if
      item%prevptr => item
    END IF
    NULLIFY(item%upptr)
  END SUBROUTINE var_list_item_remove

  ! Create a new (orphaned) list item.
  !
  FUNCTION var_context_list_newitem(something) RESULT(newitem)
    TYPE(t_comin_var_context_item), INTENT(in) :: something
    TYPE(t_var_context_list_item), POINTER :: newitem
    ALLOCATE (newitem)
    newitem%item_value = something
    newitem%prevptr => newitem
  END FUNCTION var_context_list_newitem

  ! Append an item to a list.
  !
  SUBROUTINE var_context_list_append(list, item)
    CLASS(t_var_context_list), INTENT(inout), TARGET :: list
    TYPE(t_var_context_list_item), TARGET            :: item
    TYPE(t_var_context_list_item), POINTER           :: last
    IF (ASSOCIATED(item%upptr)) CALL item%remove()
    item%upptr => list
    IF (ASSOCIATED(list%firstptr)) THEN
      last => list%firstptr%prevptr
      last%nextptr => item
      item%prevptr => last
      list%firstptr%prevptr => item
    ELSE
      list%firstptr => item
      item%prevptr => item
    END IF
  END SUBROUTINE var_context_list_append

  ! Delete the contents of a list.
  !
  SUBROUTINE var_context_list_delete_list(list)
    CLASS(t_var_context_list), INTENT(inout) :: list
    DO
      IF (.NOT.ASSOCIATED(list%firstptr)) EXIT
      CALL var_context_list_delete(list%firstptr)
    END DO
  END SUBROUTINE var_context_list_delete_list

  ! Return the first element of a list.
  !
  FUNCTION var_context_list_first(list) RESULT(first)
    CLASS(t_var_context_list), INTENT(in) :: list
    TYPE(t_var_context_list_item), POINTER :: first
    first => list%firstptr
  END FUNCTION var_context_list_first

  ! Delete an item: removes it from the list and deallocates it.
  !
  SUBROUTINE var_context_list_delete(item)
    ! We want to deallocate the dummy argument, so it must be a pointer.
    ! It follows that the procedure cannot be a type-bound procedure.
    TYPE(t_var_context_list_item), POINTER :: item
    TYPE(t_var_context_list_item), POINTER :: ptr
    ptr => item
    CALL item%remove()
    DEALLOCATE (ptr)
    NULLIFY(item)
  END SUBROUTINE var_context_list_delete

  ! Return the list that an item is a member of.  Null if an orphan.
  !
  FUNCTION var_context_list_item_list(item) RESULT(list)
    CLASS(t_var_context_list_item), INTENT(in) :: item
    TYPE(t_var_context_list), POINTER :: list
    list => item%upptr
  END FUNCTION var_context_list_item_list

  ! Return the next item in the list.
  !
  FUNCTION var_context_list_item_next(item)  RESULT(next)
    CLASS(t_var_context_list_item), INTENT(in) :: item
    TYPE(t_var_context_list_item), POINTER :: next
    next => item%nextptr
  END FUNCTION var_context_list_item_next

  ! Remove an item from a list (but keep it and its value).
  !
  SUBROUTINE var_context_list_item_remove(item)
    CLASS(t_var_context_list_item), INTENT(inout), TARGET :: item
    TYPE(t_var_context_list), POINTER :: list
    list => item%upptr
    IF (ASSOCIATED(list)) THEN
      IF (ASSOCIATED(item%prevptr, item)) THEN
        ! Single item in list.
        NULLIFY(list%firstptr)
      ELSE IF (.NOT.ASSOCIATED(item%nextptr)) THEN
        ! Last item in list.
        list%firstptr%prevptr => item%prevptr
        NULLIFY(item%prevptr%nextptr)
      ELSE IF (ASSOCIATED(list%firstptr, item)) THEN
        ! First item in list.
        list%firstptr => item%nextptr         ! first = next.
        item%prevptr%prevptr => item%nextptr  ! last%prev = item%next.
        item%nextptr%prevptr => item%prevptr  ! next%prev = last.
      ELSE
        item%prevptr%nextptr => item%nextptr  ! last%next = item%next.
        item%nextptr%prevptr => item%prevptr  ! next%prev = item%last.
      end if
      item%prevptr => item
    END IF
    NULLIFY(item%upptr)
  END SUBROUTINE var_context_list_item_remove

  ! Create a new (orphaned) list item.
  !
  FUNCTION var_request_list_newitem(something) RESULT(newitem)
    TYPE(t_comin_request_item), INTENT(in) :: something
    TYPE(t_var_request_list_item), POINTER :: newitem
    ALLOCATE (newitem)
    newitem%item_value = something
    newitem%prevptr => newitem
  END FUNCTION var_request_list_newitem

  ! Append an item to a list.
  !
  SUBROUTINE var_request_list_append(list, item)
    CLASS(t_var_request_list), INTENT(inout), TARGET :: list
    TYPE(t_var_request_list_item), TARGET            :: item
    TYPE(t_var_request_list_item), POINTER           :: last
    IF (ASSOCIATED(item%upptr)) CALL item%remove()
    item%upptr => list
    IF (ASSOCIATED(list%firstptr)) THEN
      last => list%firstptr%prevptr
      last%nextptr => item
      item%prevptr => last
      list%firstptr%prevptr => item
    ELSE
      list%firstptr => item
      item%prevptr => item
    END IF
  END SUBROUTINE var_request_list_append

  ! Delete the contents of a list.
  !
  SUBROUTINE var_request_list_delete_list(list)
    CLASS(t_var_request_list), INTENT(inout) :: list
    DO
      IF (.NOT.ASSOCIATED(list%firstptr)) EXIT
      CALL var_request_list_delete(list%firstptr)
    END DO
  END SUBROUTINE var_request_list_delete_list

  ! Return the first element of a list.
  !
  FUNCTION var_request_list_first(list) RESULT(first)
    CLASS(t_var_request_list), INTENT(in) :: list
    TYPE(t_var_request_list_item), POINTER :: first
    first => list%firstptr
  END FUNCTION var_request_list_first

  ! Delete an item: removes it from the list and deallocates it.
  !
  SUBROUTINE var_request_list_delete(item)
    ! We want to deallocate the dummy argument, so it must be a pointer.
    ! It follows that the procedure cannot be a type-bound procedure.
    TYPE(t_var_request_list_item), POINTER :: item
    TYPE(t_var_request_list_item), POINTER :: ptr
    ptr => item
    CALL item%remove()
    DEALLOCATE (ptr)
    NULLIFY(item)
  END SUBROUTINE var_request_list_delete

  ! Return the list that an item is a member of.  Null if an orphan.
  !
  FUNCTION var_request_list_item_list(item) RESULT(list)
    CLASS(t_var_request_list_item), INTENT(in) :: item
    TYPE(t_var_request_list), POINTER :: list
    list => item%upptr
  END FUNCTION var_request_list_item_list

  ! Return the next item in the list.
  !
  FUNCTION var_request_list_item_next(item)  RESULT(next)
    CLASS(t_var_request_list_item), INTENT(in) :: item
    TYPE(t_var_request_list_item), POINTER :: next
    next => item%nextptr
  END FUNCTION var_request_list_item_next

  ! Remove an item from a list (but keep it and its value).
  !
  SUBROUTINE var_request_list_item_remove(item)
    CLASS(t_var_request_list_item), INTENT(inout), TARGET :: item
    TYPE(t_var_request_list), POINTER :: list
    list => item%upptr
    IF (ASSOCIATED(list)) THEN
      IF (ASSOCIATED(item%prevptr, item)) THEN
        ! Single item in list.
        NULLIFY(list%firstptr)
      ELSE IF (.NOT.ASSOCIATED(item%nextptr)) THEN
        ! Last item in list.
        list%firstptr%prevptr => item%prevptr
        NULLIFY(item%prevptr%nextptr)
      ELSE IF (ASSOCIATED(list%firstptr, item)) THEN
        ! First item in list.
        list%firstptr => item%nextptr         ! first = next.
        item%prevptr%prevptr => item%nextptr  ! last%prev = item%next.
        item%nextptr%prevptr => item%prevptr  ! next%prev = last.
      ELSE
        item%prevptr%nextptr => item%nextptr  ! last%next = item%next.
        item%nextptr%prevptr => item%prevptr  ! next%prev = item%last.
      end if
      item%prevptr => item
    END IF
    NULLIFY(item%upptr)
  END SUBROUTINE var_request_list_item_remove


  !> compare two variable descriptors.
  FUNCTION comin_var_descr_match(var_descriptor1, var_descriptor2)
    TYPE(t_comin_var_descriptor), INTENT(IN) :: var_descriptor1, var_descriptor2
    LOGICAL :: comin_var_descr_match
    ! local
    LOGICAL :: l_name, l_domain

    l_name = (TRIM(ADJUSTL(var_descriptor1%name)) == TRIM(ADJUSTL(var_descriptor2%name)))
    l_domain = (var_descriptor1%id == var_descriptor2%id)

    comin_var_descr_match = l_name .AND. l_domain
  END FUNCTION comin_var_descr_match

END MODULE comin_variable_types
