/** 
\page solver_howto Solver Howto
@{
\attention
For proper usage of the Doxygen reference of the solver library, please make sure that \e EXTRACT_PRIVATE is set to \e YES in the Doxygen configuration.
Otherwise, the detailed interface description is not generated!

<H1>Overview</H1>

<P>
The solver modules consists of several modules:
<UL>
<LI>\link linear_algebra\endlink for basic linear algebra operations like norms and dot products</LI>
<LI>\link solver_internal\endlink for internal state and inner workings</LI>
<LI>\link solver_public\endlink defines parameters in the way of enums</LI>
<LI>\link solvers\endlink includes CG method, Chebyshev iteration and Schwarz method</LI>
<LI>\link solver_config\endlink provides functions to set up the configuration</LI>
<LI>\link spectral_methods\endlink has functionality to determine smallest and largest eigenvalues</LI>
<LI>\link preconditioners\endlink provides preconditioners for the solver like Jacobi, SSOR, ILU(0), (modified) ICC(p)</LI>
<LI>\link solver_all\endlink provides a generic \e solve function that calls the appropriate solver/preconditioner combination with respect to the configuration</LI>
</UL>
</P>

<H1>Solve function for preconditioned CG and Chebyshev</H1>

<P>
The easiest way to use the solver module is to setup all configuration and use the generic \link solver_all::solve solve\endlink function to solve a
stencil-based linear equation system A=b with the help of the CG method or Chebyshev iteration and a preconditioner.
</P>

<P>
In MPIOM, the solver configuration in generated in <TT>mo_solver_hlp.f90</TT>. There, the <TT>read_solver_config</TT> function reads the configuration from file SLVCTL and fills the type solver_config with it.
SLVCTL is generated by the <TT>preparte_job_mpiom_hamocc</TT> script. It comes with detailed comments on its usage and the meaning of the various parameters.
Additionally, this configuration is checked (<TT>check_solver_config</TT>), broadcast (<TT>broadcast_solver_config</TT>) and logged (<TT>logwrite_solver_config</TT>).
With the help of the functions <TT>get_interior</TT> and <TT>set_extents</TT> the extents of the solution vector \e z1o is set.
</P>

<P>
During the startup of MPIOM in <TT>mpiom.f90</TT>, a <TT>solver_config</TT> is generated and passed to \link solver_config::init_solver init_solver\endlink to initialize the solver library with the user-set configuration.
The actual utilization of the solver takes place in <TT>mo_tro.f90</TT> in the function <TT>solve_barotro_sys</TT>.
There, first the <TT>calc_barotro_rhs</TT> function is called to calculate the right-hand-side of the barotropic system then stencil (i.e. the linear system) of the barotropic system is set via \link solver_config::set_stencil set_stencil\endlink.
Next, the <TT>checkprep_params</TT> from <TT>mo_solver_hlp</TT> function checkes and prepares all parameters by looking at the parameters set by the solver initialization and complementing them.
For instance the eigenvalues lambda_min and max can be set in SLVCTL or are retrieved automatically during this preparation step which is executed only once.
After this a call to the \link solver_all::solve solve\endlink function solves the system. As parameters this function needs the barotropic stencil operation as given by \link solver_config::apply_stencil apply_stencil_dp \endlink, the right-hand-side \e b1o, the starting value \e z1o with its extents  \e ext_z1o as well as a function for the boundary exchange (<TT>bounds_exchange_dp</TT>) which is defined in <TT>mo_solver_hlp</TT> in MPIOM.
Since almost all functions are defined for single (suffix _sp) and double (suffix _dp) precision we pass the double precision variants of all funtions to \link solver_all::solve solve\endlink.
The corresponding code is:
\code
! Read config and initialize
slv_config = read_solver_config()
CALL init_solver(slv_config)

! Set the matrix stencil
CALL set_stencil(uf, vf, ff, ext_z1o)

! Check and prepare all parameters
CALL checkprep_params(z1o, ext_z1o)

! Solve the barotropic subsystem
kiter = solve(apply_stencil_dp,b1o,z1o,ext_z1o,bounds_exchange_dp) 
\endcode
</P>

<P>
The variable \e z1o now holds the result and \e kiter the needed iterations.
As stated before, the \link solver_all::solve solve\endlink function is just a convenient interface to the \link solvers::precond_cg_method precond_cg_method\endlink and the \link solvers::precond_chebyshev_method precond_chebyshev_method\endlink as well as all preconditioners in \link preconditioners \endlink module.
Direct usage of these two solvers is pretty self-explanatory and can be looked up easily in this reference.
</P> 

<H1>Additive Schwarz Method</H1>

<P>
The additive Schwarz method \link solvers::schwarz_method schwarz_method \endlink resides in the \link solvers \endlink module.
This method uses a local method to solve the global problem first on each partition seperately with fixed Dirichlet boundaries.
Then, the extended overlapping boundary halos are exchanged and another local problem is solved. This step is repeated until the solution of the global problem has converged.
</P>

<P>
To use this method, we first need to set up arrays with extended boundary halos.
This is done for instance via the <TT>setup_halos</TT> function (which then uses <TT>sethaloN</TT>) in <TT>mo_tro.f90</TT> of MPIOM.
This function enlarges the defining arrays of the barotropic system, i.e., \e uf, \e vf, \e ff, as well as \e z1o and \e b1o.
The next step is to use the enlarged fields \e zuf, \e zvf, \e zff to initialize the matrix stencil with \link solver_config::set_stencil set_stencil\endlink.
Then all parameters are checked again via <TT>checkprep_params</TT> in MPIOM. After this we can directly call \link solvers::schwarz_method schwarz_method \endlink with the function reference \link solver_config::apply_stencil apply_stencil\endlink.
The following code snipped illustrates this.
\code
! enlargen fields uf, vf, ff, z1o, b1o to zuf, zvf, zff, zz1o, zb1o
new_comm = setup_halos(zz1o, zuf, zvf, zff, zb1o, SLV_SCHWARZ_HALOS)

! Set up matrix stencil with extra halos
CALL set_stencil(zuf, zvf, zff, ext_zz1o)

! Check and prepare all parameters
CALL checkprep_params(zz1o, ext_zz1o)

! Solve the barotropic subsystem
kiter = schwarz_method(apply_stencil_dp, zb1o, zz1o, ext_zz1o, solve_dp, bounds_exchange_dp)

! Get result from field with extra halos
DO i=1,ie
    DO j=1,je
        z1o(i,j)=zz1o(i+SLV_SCHWARZ_HALOS-1,j+SLV_SCHWARZ_HALOS-1)
    ENDDO
ENDDO

DEALLOCATE(zz1o,zff,zb1o,zuf,zvf)
\endcode
</P>

<H1>Multi-Precision Iterative Refinement</H1>

<P>
It is also possible to use the CG method in single precision while obtaining double precision accuracy in the end.
The hope is that solving in single precision (sp) is faster than in double precision (dp) because twice as many sp numbers can be transferred in the same time as db numbers.
Also, if the VMC (on PowerPC) or SSE units (on Intel) is used, vector operations in sp can be twice as fast as in dp.
On the POWER6 architecture the VMX units as well as the compiler is quite limited according to IBM but the future POWER7+ with its VSX units will drastically increase the sp performace compared to dp.
</P>

<P>
To make future use of this approach, nearly all functions and routines in the solver library have a single and double precision variant.
This was accomplished by splitting each module into a declaration file, e.g. <TT>solvers.f90</TT> and an implementation file, e.g. <TT>solvers_multi.f90</TT>.
Preprocessor macros take care that the implementation file is included into the declaration file with the corresponding data kinds set accordingly.
Also, each name of a multi-precision function gets the suffix _sp resp. _dp for single precision resp. double
precision.
</P>

<P>The \link solver_all::iter_refinement iter_refinement \endlink implements the multi-precision iterative refinement.
It takes as parameters the stencil operations in single and double precision.
The code below illustrates the usage taken from <TT>solve_barotro_sys</TT>.

\code
ALLOCATE(uf_sp(ie,je), vf_sp(ie,je), ff_sp(ie,je))
uf_sp = REAL(uf, sp)
vf_sp = REAL(vf, sp)
ff_sp = REAL(ff, sp)
! Setup single precision matrix stencil
CALL set_stencil(uf_sp, vf_sp, ff_sp, ext_z1o)
! Setup double precision matrix stencil
CALL set_stencil(uf, vf, ff, ext_z1o)

! Check and prepare all parameters
CALL checkprep_params(z1o, ext_z1o)

kiter = iter_refinement(apply_stencil_dp, apply_stencil_sp, b1o, z1o, ext_z1o, bounds_exchange_sp)

DEALLOCATE(uf_sp, vf_sp, ff_sp)
\endcode
</P>

@}**/
